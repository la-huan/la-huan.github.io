<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ARTS,每周总结,">










<meta name="description" content="ARTS （第48周）如同认知世界，要先接近技术，才能学习到技术。">
<meta name="keywords" content="ARTS,每周总结">
<meta property="og:type" content="article">
<meta property="og:title" content="ARTS 第48周">
<meta property="og:url" content="http://yoursite.com/2020/02/22/ARTS-第48周/index.html">
<meta property="og:site_name" content="拉环的微博">
<meta property="og:description" content="ARTS （第48周）如同认知世界，要先接近技术，才能学习到技术。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-25T00:52:33.560Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ARTS 第48周">
<meta name="twitter:description" content="ARTS （第48周）如同认知世界，要先接近技术，才能学习到技术。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/02/22/ARTS-第48周/">





  <title>ARTS 第48周 | 拉环的微博</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拉环的微博</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/ARTS-第48周/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="拉环">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拉环的微博">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ARTS 第48周</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-22T15:26:55+08:00">
                2020-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="ARTS-（第48周）"><a href="#ARTS-（第48周）" class="headerlink" title="ARTS （第48周）"></a>ARTS （第48周）</h1><p>如同认知世界，要先接近技术，才能学习到技术。</p>
<a id="more"></a>
<h2 id="Algorithm-算法"><a href="#Algorithm-算法" class="headerlink" title="Algorithm 算法"></a>Algorithm 算法</h2><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</span><br><span class="line">https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span><br></pre></td></tr></table></figure>
<p>解法1</p>
<p>每次将首位和其它位置更改，然后从下一位开始递归的解法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation_</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		res = PermutationHelp(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 未排序的 提交是错误的</span></span><br><span class="line">		Collections.sort(res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">PermutationHelp</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">int</span> len = chars.length;</span><br><span class="line">		<span class="keyword">if</span> (len - idx == <span class="number">1</span>) &#123;</span><br><span class="line">			res.add(String.valueOf(chars[idx]));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; len; i++) &#123;</span><br><span class="line">				<span class="comment">// 避免重复</span></span><br><span class="line">				<span class="keyword">if</span> (i == idx || chars[idx] != chars[i]) &#123;</span><br><span class="line">					<span class="comment">// 每次交换首位进行判断</span></span><br><span class="line">					swap_(chars, idx, i);</span><br><span class="line">					ArrayList&lt;String&gt; sub = PermutationHelp(chars, idx + <span class="number">1</span>);</span><br><span class="line">					<span class="keyword">for</span> (String s : sub) &#123;</span><br><span class="line">						res.add(String.valueOf(chars[idx]) + s);</span><br><span class="line">					&#125;</span><br><span class="line">					swap_(chars, idx, i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap_</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> t = c[i];</span><br><span class="line">		c[i] = c[j];</span><br><span class="line">		c[j] = t;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解法2  字典序算法</p>
<p>注释里写了思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://blog.csdn.net/qq_40688707/article/details/80430661</span></span><br><span class="line">	<span class="comment">// 参照里面的那个字典的字典序树 可以更好理解</span></span><br><span class="line">	<span class="comment">// 找到公共前缀 然后对后面字符做 swap 然后reverse</span></span><br><span class="line">	<span class="comment">// 这种解法 其实给我的感觉就是从数学公式的推导而来的算法</span></span><br><span class="line">	<span class="comment">// 如果按那个字典序树就类似于树的前序遍历（最初的时候，会只改变后2位，然后逐渐变成后第3位(第三位改变后，再改变后2位)，以次类推）</span></span><br><span class="line">	<span class="comment">// 每次都是向前查找第一个变小的元素（即方法里的l变量） 即获取最长的公共前缀 便于改变公共前缀后面的东西</span></span><br><span class="line">	<span class="comment">// 然后从后找最后一个比l大的元素 即r 这个数字是用来替换最高位的数字的</span></span><br><span class="line">	<span class="comment">// 然后r和l的位置交换，然后reverse(l到末尾)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如012543 会找到l=2 r=5 然后交换2和5 得出013542 然后reverse 变量l后面的字符 即013245</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span>[] cs = str.toCharArray();</span><br><span class="line">		<span class="comment">// Arrays.sort(cs);</span></span><br><span class="line">		<span class="comment">// res.add(String.valueOf(cs));</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> l = cs.length - <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 向前查找第一个变小的元素 即最长的公共前缀 然后改变公共前缀后面的东西</span></span><br><span class="line">			<span class="keyword">while</span> (l &gt;= <span class="number">1</span> &amp;&amp; cs[l - <span class="number">1</span>] &gt;= cs[l]) &#123;</span><br><span class="line">				l--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (l == <span class="number">0</span>)<span class="comment">// 这种情况 就是有序度为0 例如12345已经变成了54321 即字典序树最后一种情况的时候</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> r = l;</span><br><span class="line">			<span class="comment">// 从l向后查找最后一个变大的元素</span></span><br><span class="line">			<span class="keyword">while</span> (r &lt; cs.length &amp;&amp; cs[r] &gt; cs[l - <span class="number">1</span>]) &#123;</span><br><span class="line">				r++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 交换 r和l 然后反转l之后的东西</span></span><br><span class="line">			<span class="comment">// 例如12345 可以变成12354</span></span><br><span class="line">			swap(cs, l - <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">			reverse(cs, l);</span><br><span class="line"></span><br><span class="line">			res.add(String.valueOf(cs));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (chars == <span class="keyword">null</span> || chars.length &lt;= k)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = chars.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len - k) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> m = k + i;</span><br><span class="line">			<span class="keyword">int</span> n = len - <span class="number">1</span> - i;</span><br><span class="line">			<span class="keyword">if</span> (m &lt;= n) &#123;</span><br><span class="line">				swap(chars, m, n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> t = c[i];</span><br><span class="line">		c[i] = c[j];</span><br><span class="line">		c[j] = t;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line">https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span><br></pre></td></tr></table></figure>
<p>解法1 排序法</p>
<p>因为多了个不满足条件的判断，所以需要一轮额外的循环</p>
<p>还可以用map记录每种数字出现次数的暴力法等，这种写法比较简单，这里我就不写了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution_</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		Arrays.sort(array);</span><br><span class="line">		<span class="comment">// 找出排序后的中位数</span></span><br><span class="line">		<span class="keyword">int</span> res = array[array.length / <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == res)</span><br><span class="line">				count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断出现次数是否大于一半</span></span><br><span class="line">		<span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? res : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解法2 摩尔投票法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摩尔投票法</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> val : array) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">				n++;</span><br><span class="line">				res = val;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == val) &#123;</span><br><span class="line">				n++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				n--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 一样的验证</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == res)</span><br><span class="line">				count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断出现次数是否大于一半</span></span><br><span class="line">		<span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? res : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</span><br><span class="line">https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span><br></pre></td></tr></table></figure>
<p>解法1 排序法</p>
<p>构建堆的思路 其实和这里是一样的，也是排序后获取前n个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 还可以用堆的结构 其实思路是类似的，这里我就不写了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution_</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	Arrays.sort(input);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		res.add(input[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2 使用快排的部分算法 通过找出基准点 当基准点是k的时候，就代表前k个数字已经选出来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution__</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> e = input.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> p = qucik(input, s, e);</span><br><span class="line">		<span class="keyword">while</span> (p != k - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">				e = p - <span class="number">1</span>;</span><br><span class="line">				p = qucik(input, s, e);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s = p + <span class="number">1</span>;</span><br><span class="line">				p = qucik(input, s, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">			res.add(input[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.sort(res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">qucik</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = arr[s];<span class="comment">// 基准点</span></span><br><span class="line">		<span class="keyword">while</span> (e &gt; s) &#123;</span><br><span class="line">			<span class="comment">// 从最右边开始 查找第一个小于基准点的数值</span></span><br><span class="line">			<span class="keyword">while</span> (e &gt; s &amp;&amp; arr[e] &gt;= pivot) &#123;</span><br><span class="line">				e--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 找到后，首次覆盖基准点，后续则覆盖下个循环里找到的点</span></span><br><span class="line">			<span class="comment">// 如果未找到 则s==e</span></span><br><span class="line">			arr[s] = arr[e];</span><br><span class="line">			<span class="comment">// 从右边查找第一个大于基准点的数值</span></span><br><span class="line">			<span class="keyword">while</span> (e &gt; s &amp;&amp; arr[s] &lt;= pivot) &#123;</span><br><span class="line">				s++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 找到后，覆盖前一个循环里找到的点</span></span><br><span class="line">			<span class="comment">// 如果未找到 则s==e</span></span><br><span class="line">			arr[e] = arr[s];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[s] = pivot;</span><br><span class="line">		<span class="keyword">return</span> e;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解法3 部分选择排序</p>
<p>非完整选择排序，仅循环k次，即时间复杂度为k*n</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution___</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length || k &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		<span class="comment">// 找出前K个最小 选择排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> min = i;<span class="comment">// 最小坐标</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; input.length; j++) &#123;</span><br><span class="line">				<span class="comment">// 遍历找出最小</span></span><br><span class="line">				<span class="keyword">if</span> (input[min] &gt; input[j]) &#123;</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将最小的和i进行对换</span></span><br><span class="line">			<span class="keyword">int</span> temp = input[i];</span><br><span class="line">			input[i] = input[min];</span><br><span class="line">			input[min] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">			res.add(input[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解法4 选择排序混合解法 </p>
<p> 在n和k差距较大的时候，有一定程度的优化，最差情况等于n^2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看了题解 一个从选择排序改进来的混合的解法 复杂度从变成(n^2)变成了((n-k)^2+k^2)</span></span><br><span class="line">	<span class="comment">// 在n和k差距较大的时候，有一定程度的优化，最差情况等于n^2</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length || k &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		<span class="comment">// 给前k个数字排序 这里用上一个解法里的选择排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> min = i;<span class="comment">// 最小坐标</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">				<span class="comment">// 遍历找出最小</span></span><br><span class="line">				<span class="keyword">if</span> (input[min] &gt; input[j]) &#123;</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将最小的和i进行对换</span></span><br><span class="line">			<span class="keyword">int</span> temp = input[i];</span><br><span class="line">			input[i] = input[min];</span><br><span class="line">			input[min] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; input.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 这里其实是插入排序</span></span><br><span class="line">			<span class="keyword">int</span> temp = input[i];<span class="comment">// 缓存</span></span><br><span class="line">			<span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">// 和之前的数比较</span></span><br><span class="line">			<span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="comment">// 若当前j坐标的数字更小,则往后挪一位</span></span><br><span class="line">				<span class="keyword">if</span> (input[j] &gt; temp) &#123;</span><br><span class="line">					input[j + <span class="number">1</span>] = input[j];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将缓存的数值插入到合适的位置</span></span><br><span class="line">			input[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">			res.add(input[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续子数组的和"><a href="#连续子数组的和" class="headerlink" title="连续子数组的和"></a>连续子数组的和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:&#123;6,-3,-2,7,-15,1,2,2&#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</span><br><span class="line">https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span><br></pre></td></tr></table></figure>
<p>解法1 动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray_1</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = array[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">		dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				dp[i] = dp[i - <span class="number">1</span>] + array[i];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i] = array[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (dp[i] &gt; res)</span><br><span class="line">				res = dp[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解法2 动态规划优化</p>
<p>其实这题做过，最先想到的是这种写法，本质也是动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray_</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = array[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				sum += num;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sum = num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (sum &gt; res)</span><br><span class="line">				res = sum;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解法3 递归分治</p>
<p>偶然想起这题在哪里看到过，有一个分治写法，就去找了找思路写了出来，</p>
<p>将每个序列都分成不包含中点的左序列或右序列，以及包含中点的序列，然后递归从查找。</p>
<p>这种思路是好的，将大问题拆成小问题进行查找，但是这题有更好的解法。如动态规划。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分治辅助</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray_Help</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left == right)</span><br><span class="line">			<span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 从中点拆分成左、右 以及从中点延伸</span></span><br><span class="line">		<span class="keyword">int</span> leftSum = FindGreatestSumOfSubArray_Help(nums, left, mid);</span><br><span class="line">		<span class="keyword">int</span> rightSum = FindGreatestSumOfSubArray_Help(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">int</span> midSum = FindGreatestSumOfSubArray_Help_GedMiddle(nums, left, right, mid);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), midSum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分治</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> FindGreatestSumOfSubArray_Help(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray_1</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = array[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">		dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				dp[i] = dp[i - <span class="number">1</span>] + array[i];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i] = array[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (dp[i] &gt; res)</span><br><span class="line">				res = dp[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数中1出现的个数"><a href="#整数中1出现的个数" class="headerlink" title="整数中1出现的个数"></a>整数中1出现的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</span><br><span class="line">https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span><br></pre></td></tr></table></figure>
<p>解法1暴力法</p>
<p>优点是思路简单，缺点是时间复杂度n，而且会创建n个string类型的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution_</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			String num = i + <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.length(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num.charAt(j) == <span class="string">'1'</span>)</span><br><span class="line">					count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解法2 题解里看到的解法</p>
<p>归纳特征，然后整合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123;</span><br><span class="line">		        <span class="keyword">int</span> a = n / m;<span class="comment">//除数</span></span><br><span class="line">		        <span class="keyword">int</span> b = n % m;<span class="comment">//余数</span></span><br><span class="line">		        <span class="comment">// 这里先忽略+8,a/10就是把当前位数当成个位数,判断一共出现多少个1（每10个数字出现一个1）,</span></span><br><span class="line">		        <span class="comment">// +8是考虑到如112这种情况，如果直接除以10，就丢失了111这个数字的个位。</span></span><br><span class="line">		        <span class="comment">// 因此+8,但不能+9,因为如111这种情况,+1就会导致多计算一个数字，所以末尾是1 的情况额外判断考虑，即后面的变量d</span></span><br><span class="line">		        <span class="comment">// 然后乘以m，就是乘以当前位数 ，</span></span><br><span class="line">		        <span class="comment">// 当考虑到非个位，如100，把100的个位舍去（除以10），然后用10除以10，得出结果1，因为这个结果是除以了10的，所以这里要再乘以10（如100里十位出现的次数是10次）</span></span><br><span class="line">		        <span class="comment">// </span></span><br><span class="line">		        <span class="keyword">int</span> c = (a + <span class="number">8</span>) / <span class="number">10</span> * m;</span><br><span class="line">		        <span class="comment">//这里考虑的是末尾数是1 的情况，如111 这个数字,因为上面的计算,只有加了8,就需要额外判断,即如果尾数是1，就进行加1.</span></span><br><span class="line">		        <span class="comment">//然后如果有余数,有多少个余数就会额外出现多少个1  如1515这样的数字 再计算到最后千位的时候，c就会是0，因为数字只剩下1，不整除了</span></span><br><span class="line">		        <span class="comment">//然后要计算千位上出现的次数 1001~1515即515，然后再计算1000这个数字的1次（末尾等于1的情况） 所以要+1 = 516次</span></span><br><span class="line">		        <span class="keyword">int</span> d = (a % <span class="number">10</span> == <span class="number">1</span> ? b + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">		        <span class="comment">//然后与之相对应的如2515这种情况，千位的时候，因为（2+8）/1000= 1 ，然后乘以1000，即出现1000次（1000~1999）</span></span><br><span class="line">		        cnt += c + d;</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>解法3数学公式归纳</p>
<p>参考自 <a href="https://www.jianshu.com/p/109fce1289e6" target="_blank" rel="noopener">https://www.jianshu.com/p/109fce1289e6</a></p>
<p>数学公式归纳</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数学归纳</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">long</span> diviver = i * <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">long</span> val = n % diviver - i + <span class="number">1</span>;</span><br><span class="line">			count += (n / diviver) * i + Math.min(Math.max(val, <span class="number">0</span>), i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review-英文文章"><a href="#Review-英文文章" class="headerlink" title="Review 英文文章"></a>Review 英文文章</h2><p><a href="http://kafka.apache.org/quickstart" target="_blank" rel="noopener">http://kafka.apache.org/quickstart</a></p>
<p>kafka 的helloword</p>
<h2 id="Tip-技巧"><a href="#Tip-技巧" class="headerlink" title="Tip 技巧"></a>Tip 技巧</h2><p>一、第一阶段“不知道自己不知道”，也就是无知，人所处的盲区。比如，我们以前在管理孩子时，认为要给孩子指出问题，让他改正才是对孩子的负责，因此我们不断看到孩子的问题并指出来。结果问题永远改不完，还导致孩子和家长对着干。我们以为家长已经尽力了，孩子就是不懂事不理解大人的良苦用心，其实这就是家长处在了管教孩子的无知盲区之中，不知道自己因为方法不当错误的管教孩子，还以为己做的很对。再比如你吃完饭脸上粘上一颗米粒，你没照镜子也没有和说的，你不知道，可能还觉得自己很美、到处炫耀你的靓丽呢。我上高一时不知道什么是“相对论”，但还和同学辩论的津津有味，现在想来真可笑。当自己不知道自己的无知时，看到的是别人做的不对，自己不会改正错误，也无从下手改正。</p>
<p>无知的原因受个人成长、家庭、文化的影响。例如，从孩子的问题入手管教孩子，是从家族的管理模式中学来的。有人说：“只有人家夸你的孩子好，哪有自己夸自家孩子好的，把他夸骄傲了怎么办。”这就是她的谦虚的传统认知，实际上她不知道现在很多父母以夸孩子为主。再比如一家人吃饭，是谁有空谁吃还是人凑齐了一起吃，不同的家庭有不同的习惯。我们在公共场合的大声喧哗，不出国门你不知道有些文明与我们很不同。</p>
<p>二、当别人帮你指出来，通过观察学习发现自己无知时，你就进入了“知道自己不知道”的阶段，开始有了自知。人贵有自知之明，当我们知道自己无知时，也就能谦虚向他人学习了。比如，当孩子出现不努力学习的问题时，我知道我的管理方法有问题了，我止住我原来的错误做法，开始走向新的学习之路。</p>
<p>三、当我们不断的学习，向他人请教，我们逐渐知道了很多知识，就进入了“知道自己知道”的觉察状态，能时刻反思自己的做法是否正确有效。比如我在管教孩子时，我对孩子的行为不满，一旦采取了打骂指责的办法，我当即觉察到这个办法无效且有害，立即止住、调整思维方向，发现孩子积极正向的动机，满足孩子的心理价值需要，向孩子表达我的感觉，孩子的行为就自动转化了。再比如，当我遇到困难时，一旦出现心烦气躁、抱怨他人的现象，立即觉察到这个方向无效，迅速止住、改变模式，改为我做些什么就能有所变化，只要做就有改变的可能，然后全力以赴去行动。</p>
<p>四、随着我们不断的觉察，不断的应用知道的知识做出行动，最后形成了习惯。不需要思考，大脑便自动自发的按新形成的模式去做，这就便进入了“不知道自己知道的”状态，形成了习惯成。比如，当我们已经习惯对他人欣赏认可时，“对”、“很好”会随时从嘴里冒出。我们学会开车后，在路上开车不会仔细考虑怎么加油门、刹车、打方向等，开车操作已经成了一种无意识运作。</p>
<p>我们认识新事物，学习新知识，就是不断的从无知到自知，再到觉察，最后形成习惯的过程。一个人首先让他觉察到自己的无知，才能走向自知，改变就有了可能。但从“知道”到“做到”也是一个相当难的过程，长期形成的模式很容易反复，需要不断的觉察、改变，持之以恒的坚持去做，才能逐渐形成习惯。</p>
<p>摘自 <a href="https://www.jianshu.com/p/ca8d65bf4094" target="_blank" rel="noopener">https://www.jianshu.com/p/ca8d65bf4094</a></p>
<h2 id="Share-分享"><a href="#Share-分享" class="headerlink" title="Share 分享"></a>Share 分享</h2><p><a href="https://blog.csdn.net/zhujianlin1990/article/details/60756448" target="_blank" rel="noopener">https://blog.csdn.net/zhujianlin1990/article/details/60756448</a>  zookeeper 因为hostname不匹配 导致的缓慢问题</p>
<p><a href="https://www.zhihu.com/question/291554395" target="_blank" rel="noopener">https://www.zhihu.com/question/291554395</a> 爬虫究竟是合法还是违法的？</p>
<p><a href="https://www.jianshu.com/p/109fce1289e6" target="_blank" rel="noopener">https://www.jianshu.com/p/109fce1289e6</a>  剑指offer最优解Java版-整数中1出现的次数（从1到n整数中1出现的次数）</p>
<p><a href="https://www.jianshu.com/p/ca8d65bf4094" target="_blank" rel="noopener">https://www.jianshu.com/p/ca8d65bf4094</a> 自我认识的四个阶段</p>
<p><a href="https://blog.csdn.net/happyrocking/article/details/83619392" target="_blank" rel="noopener">https://blog.csdn.net/happyrocking/article/details/83619392</a> 字典序算法详解</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ARTS/" rel="tag"># ARTS</a>
          
            <a href="/tags/每周总结/" rel="tag"># 每周总结</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/16/ARTS-第47周/" rel="next" title="ARTS-第47周">
                <i class="fa fa-chevron-left"></i> ARTS-第47周
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/01/ARTS-第49周/" rel="prev" title="ARTS 第49周">
                ARTS 第49周 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">拉环</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ARTS-（第48周）"><span class="nav-number">1.</span> <span class="nav-text">ARTS （第48周）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Algorithm-算法"><span class="nav-number">1.1.</span> <span class="nav-text">Algorithm 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的排列"><span class="nav-number">1.1.1.</span> <span class="nav-text">字符串的排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组中出现次数超过一半的数字"><span class="nav-number">1.1.2.</span> <span class="nav-text">数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小的K个数"><span class="nav-number">1.1.3.</span> <span class="nav-text">最小的K个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连续子数组的和"><span class="nav-number">1.1.4.</span> <span class="nav-text">连续子数组的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#整数中1出现的个数"><span class="nav-number">1.1.5.</span> <span class="nav-text">整数中1出现的个数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Review-英文文章"><span class="nav-number">1.2.</span> <span class="nav-text">Review 英文文章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tip-技巧"><span class="nav-number">1.3.</span> <span class="nav-text">Tip 技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Share-分享"><span class="nav-number">1.4.</span> <span class="nav-text">Share 分享</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">拉环</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
